第四章 对象与类
---------------------------------------
1.类

2.对象

3.封装

4.变量
-实例域
-对象和对象变量
-布局变量

5.方法
-访问器方法
-更改器方法
-静态域和静态方法
-值传递和引用传递
-重载
-构造方法
-初始化块
-一个对象初始化的步骤
-类的初始化

6.类的设计
-保证数据私有
-一定要对数据初始化
-不要在类中使用过多的基本类型
-不是所有的域都需要独立的访问器方法和更改器方法
-将职责过多的类进行分解
-类名和方法名要能够体现它们的职责
-优先使用不可变类

7.包
-类的导入
-静态导入
-将类放入包中
-包作用域
-类路径
-设置类路径

8.文档注释
 



------------------------------------------

   *面向对象与面向过程的区别？
**面向过程
	-优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，消耗资源。Linux等一般采用面向过程开发
	-缺点：只利解决小规模问题，不易维护和复用和扩展

**面向对象
	-优点：易维护，易复用，易扩展，因为面向对象（封装、继承、多态）的特性，使系统更加灵活，更易于维护
	-缺点：性能比面向过程低

1.*类
   概念：
	-构造对象的模板或蓝图
   组成
	-包括属性和方法
   类之间的关系
	依赖
	  概念：
		一个类A的方法操作另一个类B的实例对象。则称A依赖于B
	  注意：
		应该尽可能将相互依赖的类减少到最少。这样的话A不会因为B的改变而改变。B对A产生不了任何影响。让类之间的耦合度最小
		
	聚合
	  概念：
		类A的对象包含着类B的对象。
	继承
	  概念：
		类A继承类B的所有属性和方法，并扩展新功能。【属性也继承吗？】
2.*对象
		-对象的行为
			通过可调用的方法来定义对象的行为。就是对象方法
		-对象的状态
			对象实例域值的集合，称为对象当前的状态
		-对象标识
			辨别具有相同行为和状态的不同对象

	对象状态和对象行为相互影响。（自己举例）
		
3.封装：将数据和行为组合放在一个包里
	目的：不能让当前类直接访问其它类的实例域的时候。仅仅只能通过实例对象的方法来域实例域进行交互。
	优点：

4.量

 *实例域

	-普通的实例变量
	在一个类A
	Class A{
		private String name;
		private int a;
		private final int i=5;
	}
name、a、i的集合被称为实例域。实例变量，属于对象的，每个对象独享一份实例变量数据。


	-final实例域
	  其中被final修饰的域，必须初始化。就是必须在执行完构造方法之后，这个域的值已经被设置了。
	  1.要么直接在声明中采取赋值动作【实例域的赋值动作先于构造器执行】
	  2.在所有的构造方法中都对实例域i进行赋值（否则会报错，因为不确定创建对象的时候调用哪个构造方法）

      final修饰的变量大部分都是基本类型域和不可变类域【不可变类就是指被final修饰的类，类中的每一个方法都不会改变它的对象。String类就是不可变类。虽然其方法感觉改变了字符串，实际上每一个方法返回的都是一个新的字符串，原来那个字符串依然存在。】

	  #final修饰可变对象变量(可能会和上面造成混淆)
		private final A a;
		a=new A();
		表示的是变量a的值不能改变。【即其对象引用不能指向其它的A对象，当前对象本身可以改变】
	
此时为了保证不破坏封装性：(一个对象就像一个黑盒子，封装了所有实例变量数据）
		实例变量应该都用private修饰，确保只有自身类的方法能够访问这些实例域。
		而其它方法不能直接读写这些域。像之前封装的时候说过，必须通过对象的方法来与这写实例域进行交互。
   

-------------------------	
 *对象和对象变量(对象引用)
	-对象变量
	A a;   //一个对象变量，此时没有引用任何对象。
	-初始化对象变量  
	（1）
		a=new A();
		或a=null;(不建议，没意义)
	（2）
		A aa=new A();
		a=aa;
   	表达式new A()构造了一个A的新对象。并且它有值，值是新建的对象的引用。再将这个引用赋给变量aa。
	此时a和aa两个对象变量同时指向刚刚新创建的对象。
	在java中必须使用clone方法获得一个对象的完整拷贝(新的一个在内存中存在的一摸一样的对象【除地址外】)
---------------------------------

 *局部变量
	定义在普通方法中的变量，比必须要对其赋初始值，才能访问。


5.方法
*
 访问器方法：
	getXxx(){} 
 只返回实例变量值的方法。
 #不编写一个返回/引用可变对象/的访问器方法【破坏了封装性】

 更改器方法：
	setXxx(){}
 设置实例变量值的方法。

-----------------------
*静态域和静态方法
	*静态域
	由static修饰的域，这些域属于类变量。类的所有实例共享一个类变量。
	*静态常量
	 public static final i=5;编译后就被存入常量池中
	*静态方法
	 静态方法是一种不能向对象实施操作的方法。(因为静态方法跟随类，或称为类方法，操作的是类)
		1.如上述所说，操作的是类。那么静态方法可以调用本类静态方法，也可以直接操作类域
		2.静态方法中不能有this关键字，this关键字代表调用该方法的当前对象。静态方法属于类，与对象无关。
		3.如果非要在本类的静态方法中访问本类的实例域和普通方法，也只能new一个对象访问，得到的是一个实例的实例域，改变这个对象的实例域不影响其它对象。（但是这样做没有意义）
		4.对象可以调用对应类的静态方法。但是这个静态方法与对象无关，这样做没有意义。一般使用类名调用静态方法和静态域
	 	
	*以下两种情况在类中创建静态方法
		1.不需要访问对象的状态(实例域)，其所需参数都是通过显示参数(方法中参数列表)提供的。静态方法和静态域都属于类，我们一般用类名.静态方法/静态域
		2.一个方法只需要访问类的静态域
	*静态工厂方法
	  通过使用静态工厂方法来构造对象。
	为什么不用构造器来构造对象？用静态工厂方法构造对象的原因？
	  1.无法命名构造器。构造器需要与类同名。但实际上希望得到的实例和类名不是一个概念，所以要采用不同的名字。
	  2.需要改变所构造对象的类型。这点构造器做不到。
	*main()方法【静态】
	main方法不对任何对象进行操作。
------------------------
*值传递和引用传递
		*java中一直有这样的说法：java中不存在引用传递，只有值传递
		*实际上参数的传递都是传递的是副本。如果是基本数据类型，那么就是基本数据类型的值的拷贝。如果是引用类型，那么传递的就是引用变量值的拷贝。
			*若传入是基本数据类型的值的拷贝。我们可以得出，在被传递该值的方法中对该拷贝值进行改变，不会影响原值。
			*若传入的是引用变量的值的拷贝。因为引用变量的值指向的是引用类型的地址。那么其拷贝值也是指向引用类型的地址。所以我们可以得出，在被传递该值的方法中对该拷贝值进行改变，即是对指向的引用类型进行改变，所以会影响原引用类型的数据。

		#我们误以为的按引用调用。
	public static void swap(A x,A y) {//不工作
		  A temp;
		  temp=x;
		  x=y;
		  y=x;
	}
	public static void main(String[] args) {
		A x=new A(15,"小明");
		A y=new A(14,"小红");
		A.swap(x, y);
		System.out.println(x.name);
		System.out.println(y.name);
	}
		
		输出的结果还是 
			小明
			小红
		若传入的是引用变量的值的拷贝。因为引用变量的值指向的是引用类型的地址。swap方法中的x和y得到的只是两个对象引用的拷贝，而不是对象本身，交换完指向之后就被丢弃了，所以说看似引用传递其实还是值传递。
		#小坑：
			代码1：
			public class test1 {
		public static void main(String[] args) {
			A a=new A();
			a.data=20;
			a.method(a);
			System.out.println("main中的"+a.data);
		}
	}
			class A{
					int data=10;
				void method(A a) {
					System.out.println("A中的"+a.data);
				}
			}
	 输出：
			A中的20
			main中的20
	
		  代码2：
		public class test1 {
		public static void main(String[] args) {
			A a=new A();
			a.data=20;
			a.method(a);
			System.out.println("main中的"+a.data);
		}
	}
		class A{
				int data=10;
			void method(A a) {
				a=new A();
				System.out.println("A中的"+a.data);
			}
		}
	 输出：
		A中的10
		main中的20
	
		*比较代码1和代码2。
			-代码2中a.data没有改变的原因是：一开始传递的时候，的确传递的是main中改变后的引用变量a的副本。但是在method()方法中a新new了个对象，从一开始指向main中new的20的对象，指向新的对象，所以原本方法中的data还是10;
	
		#总结一下方法参数
			-一个方法不能修改一个基本数据类型的参数(数值型和布尔型）
			-一个方法可以改变一个对象参数的状态
			-一个方法不能让对象参数引用一个新的对象。//swap例子
			【这里的基本数据类型参数和对象参数都是值在调用方法的那一块区域的传递进去的参数，而不是指方法体的那里的参数列表】
---------------------
*重载
		-方法签名
			方法名和参数类型。
		-重载是对于一个类中同名方法的多态的体现。
	  同名函数，参数列表不同(参数类型，参数数量，参数顺序),称方法之间发生了重载。
		 #当方法签名一致【即方法名和参数类型一致就已经确定为同一个函数，此时不能返回值类型不同】
			当方法签名不一致，同名，参数列表不同，那么返回值可以不同。
-----------------------
*构造方法
	*无参构造器
        对象由无参构造器创建的时候，实例域会默认初始化值。【局部变量不同，一定要显示初始化】。
   	    仅当类没有任何构造方法的时候，系统会提供一个默认的无参数构造器。一旦有了一个构造器，系统不自动创建，无参构造器需手动创建。
	*调用另一个构造器
		this.另一个构造器。必须要写在本构造器第一行。
------------------------------
*初始化块
	无论使用哪个构造器狗仔对象，初始化都会被先运行。
------------------------------
*一个对象初始化的具体步骤
		1.所有数据域被初始化为默认值
		2.按照在类声明中出现的次序，依次执行所有的域初始化语句(声明中的赋值动作，比构造函数先执行)和初始化块
		3.如果构造器的第一行调用了另一个构造器，则率先执行第二个构造器的主体
		4.执行这个构造器的主体
---------------------------------
*类的初始化(在深入理解jvm中有详解)
		对静态域的初始化语句(赋值动作)和静态初始化块来对类进行初始化。
	
6.类的设计
 *保证数据私有
		实例域私有。保证了封装性
 *一定要对数据初始化
		不要依赖系统默认初始化。应该通过构造方法或者赋值动作等初始化方式对数据进行初始化
 *不要在类中使用过多的基本类型
		能封装成类就封装成类
 *不是所有的域都需要独立的访问器方法和更改器方法
 *将职责过多的类进行分解
		将一个功能复杂的类分解为多个功能具体明确的类
 *类名和方法名要能够体现它们的职责
 *优先使用不可变类
		

	
	

		
