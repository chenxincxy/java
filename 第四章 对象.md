第四章 对象与类
**1.面向对象程序设计（OPP）**
   *面向对象与面向过程的区别？
**面向过程**
	-优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，消耗资源。Linux等一般采用面向过程开发
	-缺点：只利解决小规模问题，不易维护和复用和扩展

**面向对象**
	-优点：易维护，易复用，易扩展，因为面向对象（封装、继承、多态）的特性，使系统更加灵活，更易于维护
	-缺点：性能比面向过程低

	***类**
		-构造对象的模板或蓝图（举例：二叉树BST 有左指针，右指针，计算size的方法等等）

		-包括属性和方法
		-方法分为具体方法和抽象方法和构造方法
			**关于构造方法
				***构造方法的重载，看参数即可。如果构造方法想要调用构造方法那么需要用this()方式调用，this()中传的参数就是就是想调用的构造方法中的参数。且注意this()必须放在第一行。

	***对象**
		-对象的行为：对对象的操作
		-对象的状态：施加方法时，对象的反应（对象的状态影响对象行为）
		-对象标识：辨别具有相同行为与状态的不同对象
		
	***封装**：将数据和行为组合放在一个包里
	***继承**：(java是单继承的，使用extends关键字)
		-当生成子类对象时，java默认在子类构造方法中第一行有一个隐式调用（看不见的super();）[即默认先调用父类不带参数的构造方法，然后执行该方法生成父类对象，再调用且执行子类构造方法，生成子类对象]=>要想生成子类对象必须先生成父类对象
		-super关键字：super表示对父类对象的引用
		-如果子类使用super()显示调用父类的某个构造方法，那么再执行的时候就会寻找与super()所对应的构造方法而不会再去寻找父类的不带参数的构造方法（即不会默认调用super()无参数，与this关键字一样，super也必须作为构造方法的第一条执行语句。
		-关于继承的3点：
			（1）父类有的，子类也有
			（2）父类没有的，子类可以增加
			（3）父类有的，子类可以改变
		-注意： a)构造方法不能被继承 b)方法和属性可以继承 c)子类的构造方法隐式调用父类的不带参数的构造方法 d)当父类没有不带参数的构造方法的时候，子类必须使用super()来显示调用父类的构造方法，super指的是父类的引用。 e)super关键字必须是构造方法中的第一行执行语句
		-方法重写：子类与父类方法的（3个一致）返回类型一致，方法名称一致，参数一致，就说子类与父类方法构成了重写关系
		-重载与重写的关系：重载发生在同一个类内部的两个或多个方法。重写发生在父类与子类之间。
		-当两个方法形成重写关系时，可以在子类方法中通过super.run()形式调用父类的run()方法。该执行语句不需要放在第一条。因为执行该语句的时候父类对象已经构造完了。
		-在定义一个类的时候，如果没有显示指定该类的父类，那么该类就会继承java.lang.Object类。
		
	***多态**：子类就是父类（男人是人），因此多态的意思就是：父类型的引用可以指向子类型的对象。
			代码例子 [那么实例化的时候可以 Animal cat=new Cat();]
				class Animal{
				public void eat(){
				}
				}
				class Cat extends Animal{
				public void eat() {
				System.out.println("吃鱼");
				}
				public void catchmouse() {
				System.out.println("抓老鼠");
				}
				}
			-Animal cat=new Cat();这条语句表示（Animal类型的引用指向Cat()类型的对象，引用指向谁调用谁的方法）cat.eat();当使用多态方式调用方法时，首先检查父类中是否有eat()方法。如果有，调用子类的eat()方法；如果没有，则编译不通过。
			-一共有两种类型的强制类型转换：
			a)向上类型转换：子类转换为父类。因为子类就是父类，所以可以直接转换，任何子类都可以转换为其父类。不需要显示转换，即不需要在前面加上小括号   Cat cat=new Cat();Animal animal=cat; 此时animal.eat()调用的是子类的eat,因为Animal类型引用指向Cat类型对象
			b)向下类型转换：将父类型转换为子类型。对于向下类型转换，必须要显示指定。而且还要有前提条件。强制转换后的类型必须是转换前所指向的对象类型。如： Animal animal=new Cat(); Cat cat=(Cat)animal; cat.eat();=animal.eat();因为此时cat和animal引用指向Cat类型对象，所以调用的是Cat类中的eat()方法。
			c）使用向下类型强转的应用：如catchmouse()方法是子类Cat特有的，那么就要进行向下强转Animal animal=new Cat(); Cat cat=(Cat)animal; cat.catchmouse(); 因为前面讲到了 Animal类型没有catchmouse方法不能调用。
	***关键字**
		***static
			-修饰属性：无论一个类生成了多少个对象，所有这些对象共同使用唯一一份静态成员遍历；一个对象对该静态成员遍历进行了修改，其它对象的静态成员变量的值也会发生变化。如果一个成员变量是static的，可以通过类名.成员变量来访问。
			
			-修饰方法：类名.方法名来访问。静态方法只能继承不能重写(面试涉及)。
					代码示例：（因为a有static修饰的静态方法，是哪个类型的引用，就调用谁的a方法）
					M m=new N();
					m.a();
					}
					}
					class M{
					public static void a() {
					System.out.println("m");
					}
					}
					class N extends M{
					public static void a() {
					System.out.println("n");
					}
					}
		***final关键字（final可叙事属性、方法、类）
			-修饰类：当一个类被final修饰时候，表示一个类是终态类，该类不能被继承。
			-修饰方法：当一个方法被final所修饰时，表示该方法是一个终态方法，不能被重写
			-修饰属性：当一个属性被final修饰时，该属性不能被改写。

					注意：（1）	当final修饰一个原生数据类型时候，表示该原生数据类型的值不能发生变化（如：10不能变到20）
						当修饰一个引用类型时，表示该引用类型的地址不能发生变化(即不能再指向其它对象了)，但是该引用
						原本所指的对象的里面内容只要没有final修饰是可以变化的。

					代码示例：
					M m=new M();
					//m.address=new Address();//The final field M.address cannot be assigned
					m.address.name="beijing";
					}
					}
					class M{
					final Address address=new Address();
					
					}
					class Address{
					String name="shanghai";
					}
						（2）对于final类型的成员变量，一般有两种赋初值的方式：（理解记忆）
							a)声明final类型的成员变量的时候就赋上初值
							b)再final类型的成员变量时不赋初值，但再类的【所有】构造方法中都为其赋上初值[如果不赋，构造方法一定会执行其中的一个或几个，那么你必须保证每一个都对final类型变量赋值了，才不会报错]


-------------待续
